{"0": {
    "doc": "About",
    "title": "Vision",
    "content": "Make everything work seamlessly . ",
    "url": "/docs/about_me/#vision",
    
    "relUrl": "/docs/about_me/#vision"
  },"1": {
    "doc": "About",
    "title": "About Me",
    "content": "Nick l1m1t A.K.A. h1ghl1kh7, go_1fy, etc. CTF Player, Vulnerability Researcher Interested in Pwn, Rev, etc. ",
    "url": "/docs/about_me/#about-me",
    
    "relUrl": "/docs/about_me/#about-me"
  },"2": {
    "doc": "About",
    "title": "Archieve",
    "content": "2023 . | CODEGATE junior finalist | CCE2023 finalist | WACon finalist | Whitehat contest 3th (사이버작전사령관상) | YISF 한국정보보호산업협회장상 | KOSPO ctf 우수상 | JBU ctf 우수상 | The Hacking Championship Junior 우수상 | ABB 해커톤 해킹 방어 부문 대상 | . 2022 . | wacon ctf finalist | yisf finalist | hack championship 장려상 | jbu ctf 우수상 | 정보보안 경진대회 단체전 최우수상 (KERIS 원장상) | 서울여자대학교 정보보호 영재 교육원 고등전문 A 교육과정 최우수상 | 한국디지털미디어고등학교 교내 프로그래밍 대회 금상 (Hack The Dimi) | . 2021 . | 서울여자대학교 정보보호 영재 교육원 중등기초 교육과정 최우수상 | 정보보안 경진대회 개인전 우수상 | 전국 중학생 IT 올림피아드 해킹 부문 은상 | . ",
    "url": "/docs/about_me/#archieve",
    
    "relUrl": "/docs/about_me/#archieve"
  },"3": {
    "doc": "About",
    "title": "Presentation",
    "content": ". | 28회 해킹 캠프 - 당신도 툴키디가 될 수 있다 (툴 소개 + Mac 취약점 분석 소개) | 제1회 CCA 화이트햇 겨울 세미나 for newbies “ROP 기법들 소개” 발표 | . ",
    "url": "/docs/about_me/#presentation",
    
    "relUrl": "/docs/about_me/#presentation"
  },"4": {
    "doc": "About",
    "title": "Contract",
    "content": "email : h1ghl1kh7@proton.me / kimhyilim.915@gmail.com discord : h1ghl1kh7 github : l1m1t . ",
    "url": "/docs/about_me/#contract",
    
    "relUrl": "/docs/about_me/#contract"
  },"5": {
    "doc": "About",
    "title": "About",
    "content": " ",
    "url": "/docs/about_me/",
    
    "relUrl": "/docs/about_me/"
  },"6": {
    "doc": "Computer Abstractions and Technology",
    "title": "Table of Contents",
    "content": ". | Introduction | 8 Great Ideas in Computer Architecture | Below Your Program | Under the Covers | Technologies for Building Processors and Memory | Performance | The Power Wall | The Sea Change: The Switch from Uniprocessors to Multiprocessors | Real Stuff: Benchmarking the Intel Core i7 | Fallacies and Pitfalls | Concluding Remarks | . ",
    "url": "/docs/background/computer/abstractions_technology/#table-of-contents",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#table-of-contents"
  },"7": {
    "doc": "Computer Abstractions and Technology",
    "title": "Introduction",
    "content": "컴퓨터의 발전 . | 컴퓨터 기술의 진전  . | Moore의 법칙(반도체 집적회로의 성능이 2년마다 2배로 증가한다)  | . | 새로운 응용 프로그램들이 실현 가능해짐  . | 자동차 내부의 컴퓨터  | 스마트폰  | 인간 게놈 프로젝트  | WWW(World Wide Web), 웹 및 네트워크  | 검색 엔진  | . | 모든 것이 컴퓨터화 되고 있음 . | IoT 등.. 냉장고, 커피포트, … | . | . 컴퓨터의 종류 . | 개인용 . | 일반적 / 다양한 소프트웨어 | 비용/성능 다양 | . | 서버용 . | 네트워크 기반 | 높은 capacity, performance, reliability가 보장되어야 함 | 고가 / 대용량 / 고성능 | 소형 ~ 빌딩 사이즈 규모 -&gt; 다양함 | . | 슈퍼 컴퓨터 . | 복잡한 과학적 / 공학적 계산에 사용 | 초고성능, but 초고가 / 전력소모 / 유지비용 등의 문제 | . | 임베디드용 . | 시스템의 요소로서 구성되어 있음 | . | . | 1 Byte = 8 bits  | Kilobyte: 2^10 bytes = 1024 bytes  | Megabyte: 2^20 bytes = 1024*1024 bytes  | Gigabyte: 2^30 bytes = 1024^3 bytes  | Terabyte: 2^40 bytes = 1024^4 bytes  | Petabyte: 2^50 bytes = 1024^5 bytes  | Exabyte: 2^60 bytes = 1024^6 bytes  ",
    "url": "/docs/background/computer/abstractions_technology/#introduction",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#introduction"
  },"8": {
    "doc": "Computer Abstractions and Technology",
    "title": "8 Great Ideas in Computer Architecture",
    "content": "| Moore’s Law를 위한 디자인 | design 간결화, 단수화 하기 위해 추상적 개념 사용 | 공통되는 / 일반적인 부분을 빠르게 함 | parallelism을 통한 성능 향상 | pipelining을 통한 성능 향상 | prediction을 통한 성능 향상 | 메모리 체계 | redundancy를 통한 dependability/reliability 향상 (RAID) ",
    "url": "/docs/background/computer/abstractions_technology/#8-great-ideas-in-computer-architecture",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#8-great-ideas-in-computer-architecture"
  },"9": {
    "doc": "Computer Abstractions and Technology",
    "title": "Below Your Program",
    "content": "graph TD A[Application Software] --&gt; B[System Software] B --&gt; C[Hardware] . | Application Software . | high-level의 언어로 쓰임 | . | System Software . | compiler, os | high-level language를 기계어 번역 | os : service code . | input / output 조절 | memory, storage 관리 | task scheduling, sharing resources | . | . | Hardware . | processor, memory, I/O controllers | . | . graph TD A[Application Software] -- Compiler --&gt; B[System Software] B -- Assembler --&gt; C[Hardware] . ",
    "url": "/docs/background/computer/abstractions_technology/#below-your-program",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#below-your-program"
  },"10": {
    "doc": "Computer Abstractions and Technology",
    "title": "Under the Covers",
    "content": "Components of a Computer . | 모든 종류의 컴퓨터는 같은 요소들을 갖추고 있다. | PC or 서버 or 임베디드 | . | Input/Output 갖춤 . | 유저-인터페이스 기기 . | display, keyboard, mouse | . | storage . | HDD, CD/DVD, flash, SSD | . | network adapter . | Connection with other computer Touchscreen | . | . | PostPC 장치들 | keyboard, mouse 대체 | Resistive, Capacitive의 센서 타입이 있음 . | 대부분이 Capacitive 사용 | Capacitive는 동시에 여러 손가락 인식하는 멀티 터치 사용 가능 | . | . Through The Looking Glass . | Screen : 시각적 그림 요소 (픽셀) . | 픽셀당 연속되는 프레임 버퍼 메모리의 순서대로 화면에 보여지는 것으로 볼 수 있음 | 연속되는 픽셀들의 표현 집합 -&gt; 그림/움직이는 그림 표현 | . | . opening the Box 분해 . | Capacative multitouch LCD Screen / 3.8V 25Wh battery / Computer board … | etc. | . Inside the Processor (CPU) . | Datapath : 데이터의 작업 수행 | Control : Datapach 순서, memory, etc. 등을 제어 | Cache memory . | 데이터에 빠르게 접근하기 위한 고속의 SRAM memory | . | . Abstractions 복잡한 문제 단순화 . | 유연할 수 있도록 도와줘서 low-level의 복잡성을 줄여준다. | Instruction set architecture(ISA, 명령어 집합 구조) . | 하드웨어/소프트웨어 인터페이스 소프트웨어는 instruction으로 구성되어 있고, 하드웨어는 이걸 실행 / instruction을 통한 데이터 교환 | . | Application binary interface . | The ISA+ system software 인터페이스] | 기초적인 세부사항과 인터페이스 | . | . Data를 위한 안전한 장소 . | 휘발성 메인 메모리(Volatile main memory) - DRAM이 여기에 속함 . | 전원이 꺼지면 명령과 데이터 손실 | . | 비휘발성 보조 메모리(Non-volatile secondary memory) . | Magnetic disk(Hard-Disk Drive) | Flash memory(Solid-State Drive, Flash drive) | Optical disk(CD, DVD) | . | . Network . | Communication, resource sharing, nonlocal access | Local area network(LAN) : Ethernet | Wide area network(WAN): the Internet | Wireless network: Wifi, bluetooth ",
    "url": "/docs/background/computer/abstractions_technology/#under-the-covers",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#under-the-covers"
  },"11": {
    "doc": "Computer Abstractions and Technology",
    "title": "Technologies for Building Processors and Memory",
    "content": "전자기술을 계속해서 진화 . | capacity + performance UPUP | cost는 감소 | . 반도체 기술 Silicon : 반도체(자유전자 X 부도체의 성능 가짐 but 전자 이동시키면 전류가 흐르는 도체의 성능을 가질 수 있음) . | 성능을 변화시키기 위해 물질을 추가함 (실리콘에 기판 새겨넣음) . | conductors (도체) | Insulators(부도체=절연체) | Switch | . | . 집적 회로(Intergrated Circuit, IC) 실리콘 웨이퍼에 패턴을 입히고, 칩을 새김 Yield(수율) : 웨이퍼당 동작하는 기판의 비율 . ※ Intel Core i7 Wafer는 300mm wafer에 280개의 칩이 있고, 32mm 공정으로 새겨짐 각 칩은 20.7*10.5mm . ",
    "url": "/docs/background/computer/abstractions_technology/#technologies-for-building-processors-and-memory",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#technologies-for-building-processors-and-memory"
  },"12": {
    "doc": "Computer Abstractions and Technology",
    "title": "Performance",
    "content": "Response Time, Throughput . | Response Time . | 하나의 task를 수행하는데 걸리는 시간 | . | Throughput . | 단위 시간 동안 얼마나 많은 일을 하는지 | . | 응답 시간과 처리량은 무엇에 영향을 받는지 . | Processor 더 빠른 것으로 교체 | 같은 종류 여러개 . | 하나의 작업을 나눠서 하진 않으므로 Response Time은 줄지 X, but 같은 시간에 더 많은 일을 할 수 있음 -&gt; Throughput은 늘어남 | . | 일반적으로 Response time을 줄이면 Throughput도 늘어나지만, Throughput을 늘린다고 Response Time도 줄어드는 건 아님 응답 시간에 초점 | . | . 상대적인 성능 . | 성능의 정의 = 1/실행시간 | . 실행시간 측정 . | Elapsed Time (경과 시간) . | 모든 측면에서의 총 응답시간, 어떤 작업의 시작부터 끝까지 총 작업시간 . | Processing, I/O, Os Overhead, idle time 모두 포함 | . | System performance를 결정하는데 사용됨 | . | CPU Time . | 주어진 일을 처리하는데 걸리는 시간 (순수한 CPU 시간) . | I/O나 다른 작업을 하는데 사용된 시간 제외 | . | user CPU time / sytem CPU time이 있음 | 프로그램이 다르면 CPU와 시스템 성능에 대해서도 다르게 영향을 받음 (프로그램 마다 다르다. CPU의 영향을 많이 받을 수도 / 시스템의 영향을 많이 받을 수도) CPU Clocking | . | Clock period : 한 클럭 싸이클 기간. rising edge 후 다음 rising edge(동일행동) 까지 걸리는 시간 . | rising edge (LOW -&gt; HIGH), falling edge (HIGH -&gt; LOW) | 단위 : ps (e.g. 250ps = 0.25ns = 250*10^-12s) | . | Clock frequency(rate) : 초당 싸이클 수 . | 단위 : Hz (e.g. 4.0GHz = 4000MHz = 4.0*10^9Hz) | . | . 한 싸이클 : rising edge 후, 다음 rising edge까지 . Clock rate(clock cycles per second in MHz or GHz) : Clock Period(Clock cycle time)의 반전 CC = 1/CR . CPU Time 성능 (cpu time 줄이기)는 아래와 같은 방법으로 향상될 수 있음 . | clock cycle 수 줄이기 | clock rate 증가 | 일은 능률적으로 해서 적게 하되, 하나 하나의 일을 훨씬 빠르게 하는 것3 | | cycle 수 대비 clock rate 조절 (clock rate 증가 -&gt; clock cycle도 증가.. / clock cycle 감소 -&gt; clock rate 감소… | 비율을 잘 맞추는게 중요함) | . | . Instruction Count and CPI instruction count . | program, ISA와 컴파일러 등에 의해 결정됨 CPI (Average Cycles per Instruction, CPI) | Clock-cycles per instruction | instruction 당 평균 cycle 수 . | cpu 하드웨어에 의해 결정됨 (CPU가 어떻게 구성되어지고 만들어져 있는지에 따라) | 만약 instruction이 다르면 -&gt; CPI도 다름 | instruction이 섞여 있으면 평균 CPI를 산출해야 함 | clock cycles / instruction count | 하나의 instruction을 실행하는데 얼마나 많은 cycle이 필요하냐 | . | . |   | GOOD | BAD | 설명 | . | CPU Time | ↓ | ↑ | 주어진 일을 처리하는데 걸리는 순수한 CPU 시간 | . | Clock period | ↓ | ↑ | 한 클럭 싸이클의 기간 | . | Clock frequency(rate) | ↑ | ↓ | 초당 싸이클 수 | . | Clock Cycle | ↓ | ↑ | 한번 반복되는 것 or 반복되는 것의 횟수 | . | Instruction Count |   |   | 실행하는 프로그램의 명령어 갯수 | . | CPI | ↓ | ↑ | instruction을 하나 실행하는데 얼마의 clock cycle이 드냐 | . CPU Time = CPU Clock Cycles * Clock Cycle Time CPU Time = CPU Clock Cycles / Clock Rate . Performance Summary 성능 의존 . | 알고리즘 : IC에 형향, CPI에 영향 | 프로그래밍 언어 : IC, CPI에 영향 | 컴파일러 : IC, CPI에 영향 | Instructions set architecture(ISA, 명령어 집합 구조) : IC, CPI, Clock Cycle Time에 영향 ",
    "url": "/docs/background/computer/abstractions_technology/#performance",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#performance"
  },"13": {
    "doc": "Computer Abstractions and Technology",
    "title": "The Power Wall",
    "content": "Wall이라는 용어를 Power/Memory에서 사용한다고 한다. CMOS : Complementary Metal Oxide Semiconductor (상보형 금속 산화 반도체)이고, 마이크로프로세서나 SRAM 등 디지털 회로를 구성하는데 사용되는 IC의 한 종류 반도체 제조 기술의 하나로, 저전력 소비, 높은 집적도, 좋은 노이즈 면적 특성, 비교적 저렴한 제조 비용 등의 특징을 가지고 있다. | . 다음은 CMOS의 에너지 소비에 관한 설명이다. | 동적 에너지 소비 . | CMOS는 주로 동적 에너지 소비를 가지고 있다. | 동적 에너지 소비는 전원이 공급된 상태에서 발생하는 에너지 소비를 의미하며, 주로 스위칭 작업 때문에 발생한다. | CMOS의 첫 에너지 소비는 동적 에너지로, clock frequency마다 on-off, off-on으로 스위치 방식으로 제어된다. | Clock frequency에 따른 에너지 소비 제어: CMOS 회로의 동작은 클록 주파수(clock frequency)에 따라서 제어됩니다. 클록 주파수는 시스템이 동작하는 속도를 결정하며, 클록 주파수가 높을수록 연산이 빠릅니다. CMOS에서는 클록 주파수가 높을 때, 즉 스위치가 빠르게 전환될 때에는 에너지 소비가 더 많이 발생합니다. | . | 스위치 방식 제어: CMOS에서는 전력 소비를 줄이기 위해 스위치 방식으로 동작합니다. 즉, 스위치가 on 또는 off 상태로 전환됩니다. 이러한 스위치 동작은 전기 신호의 변화를 유발하며, 이러한 변화가 에너지 소비의 주요 원인 중 하나입니다. CMOS 기술에서는 클록 주파수를 조절하고 스위치를 효율적으로 제어함으로써 전력 소비를 최적화하려고 합니다. | . | . | . Reducing Power . | The Power Wall . | 전력(P) = 전력(I)*전압(V) | 전력 소모가 많으면 열이 발생 -&gt; but 전력 소모는 늘면 안되고, 성능(Frequency = clock rate)는 늘려야 되고, 전압은 줄일 수 없다.. -&gt; Multi-Core ",
    "url": "/docs/background/computer/abstractions_technology/#the-power-wall",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#the-power-wall"
  },"14": {
    "doc": "Computer Abstractions and Technology",
    "title": "The Sea Change: The Switch from Uniprocessors to Multiprocessors",
    "content": "단일 프로세서 -&gt; 멀티 프로세서로의 전환이 일어나고 있음 그 이유는, 단일 프로세서의 성능 증가가 꾸준히 일어나고 있긴 하지만, 전력소모, instruction 수준의 병렬처리, 메모리 지연 등에 의한 제한이 성능 증가를 더디게 만들었기 때문에, 멀티 프로세서로의 관심이 더욱 커지고 있다. | . | . MultiProcessors . | 칩 안에 여러개의 processor들을 탑재한 것이다. (multi core) multicore를 통한 성능 향상을 보려면, parallel 프로그래밍이 필요하다. 즉, 프로그램 자체가 바뀌어야 한다는 것인데, 이를 위해서는 프로그래머가 일일이 parallel 프로그래밍을 해야한다. Load Balancing을 통해 다수의 프로세서가 비슷한 양의 일을 나눠서 하게 해야 효율적인데, 이걸 프로그래머가 일일이 맞추는 것은 굉장히 어렵다. 또한, communication과 synchronization의 최적하가 필요한데, 요것도 힘듬 | . instruction 수준의 parallism(하드웨어가 알아서 명령을 동시에 실행하는 것) . | 하드웨어가 다수의 명령을 동시에 알아서 처리함 | 프로그래머가 신경 쓰지 않아도 됨 ",
    "url": "/docs/background/computer/abstractions_technology/#the-sea-change-the-switch-from-uniprocessors-to-multiprocessors",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#the-sea-change-the-switch-from-uniprocessors-to-multiprocessors"
  },"15": {
    "doc": "Computer Abstractions and Technology",
    "title": "Real Stuff: Benchmarking the Intel Core i7",
    "content": "SPEC CPU Benchmark (Standard Performance Evaluation Corp) 실제 workload만한 작업을 시켜서 성능을 테스트하는 프로그램 . | . SPEC CPU2006 . | 선택한 여러 프로그램들을 실행하는데 총 경과된 시간 . | CPU에 집중된 프로그램들로, I/O는 무시할 만한 수준으로 하기에, CPU Performance에 초점을 맞춰 테스팅 할 수 있다. | . | 기준머신에 대한 정규화 (기존에 기준으로 잡은 머신에 비해 얼마냐 향상되었는지 볼 수 있음) | 성능비(performance ratio)들의 기하 평균으로 요약된다. | . SPEC Power Benchmark 다른 workload 수준들에서 server의 전력 소모 측정 . | performance : throughput으로 측정된다. 초당 수행한 단위 작업의 수로 측정됨 | ssj_ops는 (server side java operations per second) | power: watts(W) (=J/s) ssj_ops / W의 단위가 클 수록, 전력 대비 많은 작업을 수행한 것이므로, 클 수록 성능이 좋은 것으로 볼 수 있다. | . ",
    "url": "/docs/background/computer/abstractions_technology/#real-stuff-benchmarking-the-intel-core-i7",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#real-stuff-benchmarking-the-intel-core-i7"
  },"16": {
    "doc": "Computer Abstractions and Technology",
    "title": "Fallacies and Pitfalls",
    "content": "컴퓨터의 어떤 부분을 향상시키면, 전체적인 성능에서도 비례적인 향상을 기대할 수 있다. 전체 작업 중 P%의 부분에서 S배의 성능이 향상되었을 때, 전체 시스템에서 최대 성능 향상은 위와 같다. 개선 후의 실행시간 = (개선에 의해 영향을 받는 실행 시간 / 성능 향상 비율) + 영향을 받지 않는 실행 시간 즉, 시스템의 한 부분의 성능이 향상되면, 전체 시스템의 성능 향상은 해당 시스템이 차지하는 비율에 비례해서만큼만 향상된다. -&gt; 뭘 하든 한 부분이 향상되면, 전체적으로 향상된다. but 시스템에서 가장 많은 부분을 차지하는 부분을 향상시키는게 가장 best이다. Fallacy : Low Power at Idle 착오 : 유휴 상태에선 저전력인가?? load와 전력소모가 비례하진 않는다. | Load(%) | Power(W) | . | 100 | 258 | . | 50 | 170 | . | 10 | 121 | . load와 전력소모가 비례하지 않음 . 프로세서를 설계할 때, load에 비례한 전력 소모가 이뤄질 수 있도록 하는게 가장 이상적이다. Fitfall: MIPS as a Performance Metric 함정 : 성능 지표로서의 MIPS MIPS (Millions of Instructions per second) 초당 몇백만개의 instruction 실행 예전에는 성능의 지표로 쓰였으나, MIPS는 많은 오해를 불러일으킬 수 있음 . | 컴퓨터마다 ISA가 다름 | instruction 마다 복잡도가 다름 (CPI가 다름) | 같은 CPU에서도 프로그램에 따라 CPI가 달라짐 -&gt; MIPS를 하드웨어의 성능측정 단위라고 하기 어렵다. 앞서 본 SPEC의 Benchmark를 사용하는 것이 더 정확하다고 할 수 있다. | . ",
    "url": "/docs/background/computer/abstractions_technology/#fallacies-and-pitfalls",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#fallacies-and-pitfalls"
  },"17": {
    "doc": "Computer Abstractions and Technology",
    "title": "Concluding Remarks",
    "content": ". | Performance/cost는 증가하고 있다. | 추상화의 계층적인 층 구조 . | 하드웨어, 소프트웨어 양 쪽 측면 모두 계층화 되고 있다. (?) | . | instruction set architecture(ISA) . | 하드웨어/소프트웨어 사이의 데이터/명령 교환(interface) | . | Execution time : 성능 측정에 있어서 최고의 도구 | Power(전력소모)를 줄이는데에는 한계가 존재한다. | Voltage, Clock rate등을 봤을 때 어느정도 미미한 발전은 있을 수 있지만, 드라마틱한 발전을 기대하긴 힘들다. | 따라서, 성능 향상을 위해 parallelism을 사용한다. | . | . CPU Time = instruction count * CPI * Clock Cycle Time (Clock Cycle Time * Clock Cycle) Performance는 Executino Time에 반비례한다. ",
    "url": "/docs/background/computer/abstractions_technology/#concluding-remarks",
    
    "relUrl": "/docs/background/computer/abstractions_technology/#concluding-remarks"
  },"18": {
    "doc": "Computer Abstractions and Technology",
    "title": "Computer Abstractions and Technology",
    "content": " ",
    "url": "/docs/background/computer/abstractions_technology/",
    
    "relUrl": "/docs/background/computer/abstractions_technology/"
  },"19": {
    "doc": "ARM64",
    "title": "Table of Contents",
    "content": ". | Architecture . | 소개 | ARM64 V8 . | ALU | . | . | Mitigation . | MTE . | Background | Bypass | . | . | 레지스터 . | Xn ( 64bit ) | Wn ( 32bit ) | Sn ( 32bit floating point ) | Dn ( 64bit floating point ) | 특수목적 레지스터 (amd64와 비교) | . | ARM64 명령어 . | STORE . | STP | STR | . | MOVE . | MOV | MOV[K|N|Z] | . | BRANCH . | B | BL | BR | BLR | . | LOAD . | LDR | LDP | . | ADDRESS . | ADR | ADRP | . | RETURN . | RET | . | ARITHMETIC . | add | sub | mul | div | . | . | Reference | . ",
    "url": "/docs/background/arm64/#table-of-contents",
    
    "relUrl": "/docs/background/arm64/#table-of-contents"
  },"20": {
    "doc": "ARM64",
    "title": "Architecture",
    "content": " ",
    "url": "/docs/background/arm64/#architecture",
    
    "relUrl": "/docs/background/arm64/#architecture"
  },"21": {
    "doc": "ARM64",
    "title": "소개",
    "content": ". | IoT, 스마트폰 등 다양한 기기에서 쓰인다. | 대표적인 RISC 계열의 마이크로프로세서이다. (RISC 계열 : 복잡한 명령어들 없애고 사용 빈도 높은 명령어들만 남겨두기, 복잡한 처리는? 소프트웨어에게 넘기기) | 명령어 셋의 개수는 적고, 레지스터가 굉장히 많다. | . ",
    "url": "/docs/background/arm64/#%EC%86%8C%EA%B0%9C",
    
    "relUrl": "/docs/background/arm64/#소개"
  },"22": {
    "doc": "ARM64",
    "title": "ARM64 V8",
    "content": ". | 물리 주소 범위가 확장되었다. | 4GB 이상의 가상 메모리 사용가능하다. | 하드웨어 암호화 명령어 지원으로 암호화 및 복호화 성능이 향상했다. | . ALU . 32bit 연산이 가능한 ALU가 제공된다. 보통 다른 CPU에서는 shift 명령이 따로 존재하지만, ARM 에서는 명령어의 옵션으로 적용 시킬 수 있다. ",
    "url": "/docs/background/arm64/#arm64-v8",
    
    "relUrl": "/docs/background/arm64/#arm64-v8"
  },"23": {
    "doc": "ARM64",
    "title": "Mitigation",
    "content": " ",
    "url": "/docs/background/arm64/#mitigation",
    
    "relUrl": "/docs/background/arm64/#mitigation"
  },"24": {
    "doc": "ARM64",
    "title": "MTE",
    "content": "Background . Memory Tagging Extension for enhancing memory safety through architecture . memory safety를 겨냥한 보호 기법들에는 ASan, HWSAN 등 소프트웨어 기법들이 있다. 다만, 성능과 배터리 측면에서 널리 배포해서 사용하기에는 무리가 있다. Armv8.5-A의 Memory Tagging Extension (MTE)는 이런 문제에 겨냥해서 나왔다. 성능과 보안성 둘 다 어느정도 잡았다. (unsafe한 language에서도 어느정도 안전함) instrument 없이 Spatial, Temporal safety의 침해를 막았다. | Buffer Overflow detection . | 메모리 할당 시에 포인터의 상위 비트에 태깅 정보를 설정하고 (파란색), 이 포인터를 통해 할당된 영역 범위 이상의 범위를 참조하게 되면 (노란색) 일종의 segmentation fault를 발생시킨다. | . | Use-After-Free detection . | 포인터 해제 시점에 메모리에 다른 태깅 정보 (혹은 태깅 초기화)를 설정하고, 해당 포인터를 통해 기존 메모리 영역에 접근하게 되면 (연두색) 마찬가지로 segmentation fault를 발생시킨다. 이런 원리로 out-of-scope나 각종 boundary violation 탐지가 가능하다. 하드웨어 Memory Controller를 통해서, 태깅 정보가 다른 경우에 SIGSEGV를 발생시켜서, 결과적으로는 SEGV_MTESERR (동기모드, 실시간 탐지), SEGV_METAERR (비동기모드) 에러를 발생시킴 | . | . MTE instruction 태그 생성하고 메모리와 포인터에 태깅하면 된다. | IRG : 랜덤 태그를 할당하는 명령어 | STG, STZG : allocation tag를 메모리에 저장하는 명령어 | LDG : 메모리에서 allocation tag를 로딩하고, address tag를 생성하는 명령어 포인터와 메모리 접근 시마다 태깅 정보를 비교하는 것은 Memory controller를 통해 수정 가능하다고 한다. | . Bypass . | Known-tag-bypasses . | 일반적으로, mitigation으로써 memory-tagging의 효용성에서 중요한 부분은 tag values의 신뢰성이다. | tag 신뢰성의 위반은 공격자가 직접적/간접적으로 그들의 invalid memory access가 정상적으로 tagged 됐다고 하고 결과적으로 탐지되지 않는다. | . | Unknown-tag-bypasses . | 구현의 한계는 attacker가 탐지될 수 있는 잘못된 태그로 memory access를 시도하더라도 취약점을 exploit 할 가능성이 존재한다는 것이다. (다만 대부분의 unknown-tag-bypasses는 sync-MTE로 막힐 것 같긴하다.) | . | . ",
    "url": "/docs/background/arm64/#mte",
    
    "relUrl": "/docs/background/arm64/#mte"
  },"25": {
    "doc": "ARM64",
    "title": "레지스터",
    "content": " ",
    "url": "/docs/background/arm64/#%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0",
    
    "relUrl": "/docs/background/arm64/#레지스터"
  },"26": {
    "doc": "ARM64",
    "title": "Xn ( 64bit )",
    "content": ". | X0 ~ X7 : Arguments &amp; ret values | X8 : Indirect result | X9 ~ X15 : Temporary | X16 ~ X17 : Intra procedure call temporary | X18 : Platform define use | X19 ~ X28 : Temporary | . ",
    "url": "/docs/background/arm64/#xn--64bit-",
    
    "relUrl": "/docs/background/arm64/#xn--64bit-"
  },"27": {
    "doc": "ARM64",
    "title": "Wn ( 32bit )",
    "content": " ",
    "url": "/docs/background/arm64/#wn--32bit-",
    
    "relUrl": "/docs/background/arm64/#wn--32bit-"
  },"28": {
    "doc": "ARM64",
    "title": "Sn ( 32bit floating point )",
    "content": " ",
    "url": "/docs/background/arm64/#sn--32bit-floating-point-",
    
    "relUrl": "/docs/background/arm64/#sn--32bit-floating-point-"
  },"29": {
    "doc": "ARM64",
    "title": "Dn ( 64bit floating point )",
    "content": " ",
    "url": "/docs/background/arm64/#dn--64bit-floating-point-",
    
    "relUrl": "/docs/background/arm64/#dn--64bit-floating-point-"
  },"30": {
    "doc": "ARM64",
    "title": "특수목적 레지스터 (amd64와 비교)",
    "content": ". | X29 : frame pointer (= SFP) | X30 : link register (= RET) | SP : stack pointer (= RSP) | PC : program counter (= RIP) | XZR : zero register (64bit, 32bit는 WZR) | . ",
    "url": "/docs/background/arm64/#%ED%8A%B9%EC%88%98%EB%AA%A9%EC%A0%81-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-amd64%EC%99%80-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/background/arm64/#특수목적-레지스터-amd64와-비교"
  },"31": {
    "doc": "ARM64",
    "title": "ARM64 명령어",
    "content": " ",
    "url": "/docs/background/arm64/#arm64-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/background/arm64/#arm64-명령어"
  },"32": {
    "doc": "ARM64",
    "title": "STORE",
    "content": "STP . | Store Pair of registers | . stp x29, x30, [sp, #-32]! . prologue 상황에서 주로 발생한다. | sp를 sp-32 위치로 이동. | 해당 위치에 x29 저장 | 해당 위치+8에 x30 저장 | . stp x29, x30, [sp, #-32] (느낌표가 없다.) . 보통의 경우 존재하지 않는 상황일 것이다. | x29를 sp-32 위치에 저장 | x30을 sp-24 위치에 저장 | . STR . | Store register | . str x1, [x2], #8 . | x2의 주소에 x1값 저장 | x2주소 +8 증가 | . str x1, [x2, #16] . | x2+16의 주소에 x1값 저장 | . STRB, STRH, STR 이라는 명령어가 존재함 . | STRB : byte, 8bits | STRH : halfword, 16bits | STR : word, 32bits (doubleword, 64bits) | . ",
    "url": "/docs/background/arm64/#store",
    
    "relUrl": "/docs/background/arm64/#store"
  },"33": {
    "doc": "ARM64",
    "title": "MOVE",
    "content": "MOV . | move register | . mov x29, sp . | sp의 값을 x29로 옮김 | . mov x1, 0x100, lsl #16 . | 0x100을 4비트 left shift한 값을 x1에 저장 (x1=0x100«4) | . mov 뒤의 bit shift 연산에는 lsl, ror 등이 존재한다. MOV[K|N|Z] . movk R0, #0x1234 → mov with keep . | R0 레지스터의 하위 16비트에 0x1234 값 넣기 (keep) | . movn R1, #0xff → mov with not . | R1 레지스터의 하위 8비트를 0xff 값으로 반전 (모두 반전) | . movz R2, #0xfff → mov with zero . | R2 레지스터의 하위 12비트를 0xfff값으로 설정 (비트를 모두 1로 설정) | . (movz, movk는 동일한 결과를 이끌어낸다.) . ",
    "url": "/docs/background/arm64/#move",
    
    "relUrl": "/docs/background/arm64/#move"
  },"34": {
    "doc": "ARM64",
    "title": "BRANCH",
    "content": "B | BL | BR | BLR . | branch / jump | . b &lt;label&gt; . | label로 이동한다. | . bl &lt;label&gt; . | 0x30 레지스터에 pc+4주소 저장 | label로 점프 | . br &lt;register&gt; . | register 주소로 이동 | . brl &lt;register&gt; . | 0x30 레지스터에 pc+4 주소 저장 | register로 점프 | . ",
    "url": "/docs/background/arm64/#branch",
    
    "relUrl": "/docs/background/arm64/#branch"
  },"35": {
    "doc": "ARM64",
    "title": "LOAD",
    "content": "LDR . | load register | . ldr x1, [x2, #16] . | x2+16 주소에 있는 값 읽기 | x1에 저장 | . ldr x1, [x2], #8 . | x2에서 값 읽기 | x1에 저장 | x2에 8 더하기 | . LDP . | load pair of register | . ldp x0, x1, [sp, #8] . | sp+8에 있는 메모리 값을 x0에 로드 | sp+16에 있는 메모리 값을 x1에 로드 | . ldp x0, x1, [sp], #8 . | sp+8의 값을 x0에 로드 | sp+16의 값을 x1에 로드 | sp = sp+8 | . ",
    "url": "/docs/background/arm64/#load",
    
    "relUrl": "/docs/background/arm64/#load"
  },"36": {
    "doc": "ARM64",
    "title": "ADDRESS",
    "content": "ADR | ADRP . | get address | . adr x1, loop . | loop 레이블의 주소를 x1에 저장 | . (컴파일 타임에 레이블의 주소를 가져와서 상대적으로 빠르게 주소를 얻어올 수 있다.) . adrp의 경우, adr과 수행하는 동작은 같지만, adrp는 4kb 정렬된 페이지의 주소를 얻어올 때 사용된다. 0x1023 . | adr : 0x1023 | adrp : 0x1000 (하위 12비트) | . ",
    "url": "/docs/background/arm64/#address",
    
    "relUrl": "/docs/background/arm64/#address"
  },"37": {
    "doc": "ARM64",
    "title": "RETURN",
    "content": "RET . | return | . ret . | 0x30 레지스터로 점프 | . ret x1 . | x1 레지스터로 점프 | . ",
    "url": "/docs/background/arm64/#return",
    
    "relUrl": "/docs/background/arm64/#return"
  },"38": {
    "doc": "ARM64",
    "title": "ARITHMETIC",
    "content": "add | sub | mul | div . ",
    "url": "/docs/background/arm64/#arithmetic",
    
    "relUrl": "/docs/background/arm64/#arithmetic"
  },"39": {
    "doc": "ARM64",
    "title": "Reference",
    "content": "https://googleprojectzero.blogspot.com/2023/08/mte-as-implemented-part-2-mitigation.html . ",
    "url": "/docs/background/arm64/#reference",
    
    "relUrl": "/docs/background/arm64/#reference"
  },"40": {
    "doc": "ARM64",
    "title": "ARM64",
    "content": " ",
    "url": "/docs/background/arm64/",
    
    "relUrl": "/docs/background/arm64/"
  },"41": {
    "doc": "Background",
    "title": "Background",
    "content": "For my background knowledge . ",
    "url": "/docs/background/background/",
    
    "relUrl": "/docs/background/background/"
  },"42": {
    "doc": "Computer",
    "title": "References",
    "content": ". | ydeer.tistory.com | . ",
    "url": "/docs/background/computer/computer/#references",
    
    "relUrl": "/docs/background/computer/computer/#references"
  },"43": {
    "doc": "Computer",
    "title": "Computer",
    "content": "About Computer Science . 컴퓨터의 시스템의 구성, 동작 원리와 설계 등을 다룸 컴퓨터 성능, 명령집합, 제어와 마이크프로그래밍, 파이프라인, 정수와 부동소수 연산, 기억부 시스템, 입출력 부시스템, 고급 컴퓨터 구조 등의 내용을 배움 고속 Data Network 시스템에 들어가는 여러 Processors들을 이해하고, 이들을 설계 또는 프로그래밍 할 수 있는 능력을 배양한다. ",
    "url": "/docs/background/computer/computer/",
    
    "relUrl": "/docs/background/computer/computer/"
  },"44": {
    "doc": "Config",
    "title": "Config",
    "content": "For my config . ",
    "url": "/docs/config/config/",
    
    "relUrl": "/docs/config/config/"
  },"45": {
    "doc": "CTF",
    "title": "CTF",
    "content": "For my CTF writeup . ",
    "url": "/docs/ctf/ctf/",
    
    "relUrl": "/docs/ctf/ctf/"
  },"46": {
    "doc": "h1ghl1kh7",
    "title": "h1ghl1kh7",
    "content": "(㇏(•̀ᵥᵥ•́)ノ) (㇏(•̀ᵥᵥ•́)ノ) . ",
    "url": "/",
    
    "relUrl": "/"
  },"47": {
    "doc": "h1ghl1kh7",
    "title": "h1ghl1kh7",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"48": {
    "doc": "Javascript",
    "title": "Javascript",
    "content": " ",
    "url": "/docs/background/javascript/",
    
    "relUrl": "/docs/background/javascript/"
  },"49": {
    "doc": "Javascript",
    "title": "Table of Contents",
    "content": ". | background . | 자바 스크립트 엔진 | 실행 컨텍스트 (Execution context) | 콜스택 | 메모리 힙 | Scope | 함수 | 클래스 / 객체 / 인스턴스 | Promise | 모듈 | 비동기 처리 | 변수 | Reference | . | Node vm . | DoS attack | Escaping the Sandbox | . | . ",
    "url": "/docs/background/javascript/#table-of-contents",
    
    "relUrl": "/docs/background/javascript/#table-of-contents"
  },"50": {
    "doc": "Javascript",
    "title": "background",
    "content": "자바 스크립트 엔진 . 자바스크립트 엔진은 코드를 실행하기 전에 Lexical Environment 내에 있는 메모리에 함수, 변수 선언을 추가한다. | 함수와 변수 선언 스캔 | Lexical Environment라고 불리는 자바스크립트 데이터 구조 내 메모리에 추가 | 코드 실행 | . 실행 컨텍스트 (Execution context) . | 실행 코드에 제공할 정보들을 모아 놓은 객체 | 생성 단계 . | 실행 컨텍스트 생성 | 선언문만 실행해서 Environment Record에 기록 (실질적인 값 할당은 아닌 듯 하다/선언문의 실행과 값 할당은 다르다.) . | 환경 레코드에 식별자 정보 저장 | 외부 렉시컬 환경 참조 -&gt; 스코프 체인 형성 | this에 바인딩 될 값 결정 | . | . | 실행 단계 . | 선언문 외 나머지 코드 순차적 실행 | Environment Record에 미리 기록된 정보 참조 or 업데이트 | . | call stack에 쌓이며 전역 컨텍스트는 자동으로 먼저 생성되고, 함수 호출 시 함수 컨텍스트가 생성된다. 이렇게 생성된다고 한다. 실제 사용되는 정보는 렉시컬 환경, 환경 레코드와 아우터이다. | 렉시컬 환경 (어휘적 환경, Lexical Environment) . | identifier-variable 매핑 정보를 가지고 있는 데이터 구조이다. | 환경 레코드 : 식별 지정자 저장 . | 호이스팅 : 인터프리터가 코드를 실행하기 전에 함수, 변수, 클래스 또는 import 선언문을 해당 범위(스코프)의 맨 위로 끌어롤리는 것처럼 보이는 현상 + 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것 . | 자바 스크립트 엔진이 전역 실행 컨텍스트 생성 -&gt; 콜 스택에 삽입 | 전체 코드 스캔, 선언 | Environment Record에 새로운 식별자 (변수) 기록 | 값 초기화 (var의 선언이 undefined로 초기화 되는 반면, let/cost의 선언은 uninitialized로 남아있다고 한다 -&gt; 초기화 되지 않음 -&gt; 참조 불가) Temporal Dead Zone(일시적 사각지대) : let/const로 선언했을 때, 선언 이전에 식별자를 참조할 수 없는 구역 | . | 자바스크립트는 오직 선언만을 hoist한다. 초기화(할당)을 hoist 하는건 아니다. (아마 추상적으로 이렇게 있다 만 해놓고 나머지는 나중에 코드 실행할 때 하는 듯) -&gt; 함수를 위에서 먼저 실행할 때 사용됨 -&gt; 미리 있다 라는 것만 저장? 하는 느낌? | 함수 선언식은 hoisting 되지만, 함수 표현식은 호이스팅 되지 않는다. -&gt; (위의 자바스크립트는 선언만 hoist하기 때문. 다만, 함수 선언식의 경우, 여러 선언식이 같은 이름으로 존재할 경우, 가장 마지막으로 선언된 함수를 따와서 실행하기 때문에, 주의해야 한다. console.log(aa) var aa=2 . | 위와 같은 코드가 있을 때는, aa가 hoist되었기에, 출력의 결과는 undefined로 나온다. | . | Outer Environment Reference : 실행 컨텍스트를 잇는 연결다리 . | 스코프 체인 Scope | 바깥 Lexical Environment를 가리킨다. | . | . | . | . 실행 컨텍스트 (Execution Context) : { 동적인 환경 (Variable Environment) : {…}, 어휘적 환경 (Lexica lEnviroment) : { 환경 레코드(Environment Record): { 객체적 환경 레코드(Object Environment Record), 선언적 환경 레코드(Declarative Environment Record): { 함수 환경 레코드(Function Environment Record), 모듈 환경 레코드(Module Environment Record) }, 디스 바인딩( `this` binding) }, 외부 환경에 대한 참조(Reference to the outer environment) } } . 위처럼 이해하면 될 것 같다. | 동적 환경 : 변수(var) 바인딩 저장 | 어휘적 환경 : 함수 선언 및 변수 (let, const) 바인딩 저장 . | 환경 레코드 : Lexical 환경 안에 변수와 함수의 선언 저장 / 함수 컨텍스트의 경우 인수를 포함하여 저장 . | 객체적 환경 레코드 : 변수와 함수 선언과는 별도로 전역 바인딩 객체 (브라우저의 경우 window 객체) 저장. 따라서, 바인딩 오브젝트의 각 속성에 대해 레코드에 새로운 엔트리가 생성 | 선언적 환경 레코드 : 변수와 함수 선언 저장 . | 함수 환경 레코드 : 함수의 최상위 스코프를 나타내는데 사용되는 선언적 환경 레코드. 화살표 함수가 아니라면 this 바인딩을 제공하며 화살표 함수가 아니고 super를 참조하는 경우 super 메서드를 실행하는데 필요한 state 제공 [[Javascript#함수]] . | 모듈 환경 레코드 : Module의 외부 스코프를 나타낼 때 사용하는 선언적 환경 레코드, 변경이 가능함, 변경 불가능한 바인딩과 더불어 변경 불가능한 import 바인딩 (immutable import binding) 제공 | . | this 바인딩 : this의 값이 결정되거나 설정 | . | . | 외부 환경에 대한 참조 : 스코프 체인 결정 | . | . 콜스택 . | 실행 컨텍스트를 저장하는 자료구조 | 원시 타입의 데이터 저장됨 | 실행 컨텍스트를 통해 변수 식별자(이름) 저장, 스코프 체인 및 this 관리, 코드 실행 순서 관리 등을 수행 | 원시 타입 . | 주소 / 값 형태로 이루어짐 | 변수에 데이터 할당 시, 변수는 해당 데이터를 가진 주소를 가리키게 된다. | 데이터 타입이 원시 타입이 아닌경우, 원시 타입의 값은 그 데이터를 가진 메모리 힙에 주소를 가리키게 됨 | 변수 식별자 자체는 콜스택 상의 실행컨텍스트의 렉시컬 환경이라는 곳에 저장된다. | . | 변수에 할당된 값을 바꾸면, 실제 메모리의 값을 바꾸는 것이 아닌, 다른 변수에 값이 할당되어 있는지를 확인하고 해당 주소를 참조한다. (변수의 주소가 같아질 수도 있다.) | 만약 없으면, 메모리 공간을 새로 생성한 후, 그 주소가 변수의 주소로 할당될 수도 있다. | 아무 변수도 참조하고 있지 않은 원시타입이 존재할 경우, 가비지 컬렉터가 알아서 제거한다. | const 타입은 위와 같은 방식으로 동작이 불가능하다. (초기값 할당이 필수이기 때문) 메모리 힙 . | 참조타입(객체 등) 데이터가 저장되며 구조적이지 않다. | 배열과 같은 참조 타입 데이터가 메모리 힙에 저장된다. | 메모리 힙의 주소값이 콜 스택에 저장된다. | 배열의 값이 바뀌면 메모리 힙에 저장된 배열의 값이 바뀌는 것이다. Scope . scope라는 함수의 내부에서는 global variable의 값을 참조할 수 있다. | 함수 레벨 스코프 . | 함수 안에 있으면 참조 가능 (var) | . | 블록 레벨 스코프 . | { } 안에 있어야 참조 가능 (let, const는 블록 레벨 스코프 ES6) | . | 스코프는 필요한 영역에 한정하여 유효 범위가 좁을 수록 좋다. 스코프 체인 | 자신이 속해있는 지역의 변수들을 참조할 수 있게 되며, 해당 코드 레벨에 참조값이 없다면 상위 레벨의 스코프로 참조값을 찾아나가는 현상 | 변수 은닉화 (Variable Shadowing) . | 스코프 체인에 따라 밖으로 슉슉 찾아가는 스코프 체인 과정 중, 동일한 변수가 현재 스코프에 존재함과 동시에, 상위 스코프에도 존재할 경우, 현재 스코프에 존재하는 값을 가져오기 때문에, 상위 스코프의 식별자 값은 가려진다. | 위 현상을 변수 은닉화라고 한다. 정적 / 렉시컬 스코프 | . | 함수를 호출한 곳이 아닌 선언한 곳을 기준으로 스코프를 결정하는 원칙 | . let greet = 'Hello'; function sayHi() { let greet = 'Hi'; print(); } function print() { console.log(greet); } sayHi(); // 예상: \"Hi\" | 출력값: \"Hello\" print(); // 예상: \"Hello\" | 출력값: \"Hello\" . 위 처럼, print 함수를 main / sayHi에서 각각 호출하고 있지만, 최종적인 결과값은 둘 다 전역 변수의 값으로 나온다. | module level scope 모듈 내부에서 정의한 변수나 함수는 다른 스크립트에서 접근할 수 없음 함수 . 바인딩 : 실별자와 값 연결 변수 선언 -&gt; 변수 이름 + 메모리 공간의 주소 바인딩 (할당은 아닌 듯 하다) 객체 안에 선언된 함수 : 메소드 (전역에서 선언된 일반 함수도 결국 전역 객체의 메소드 -&gt; 모든 함수는 객체 내부에 있음) . | this . | features . | javascript 예약어 | 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 (self-reference variable) | 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있음 | this는 js 엔진에 의해 암묵적으로 생성된다. | this는 코드 어디서는 참조할 수 있다. | 자기 참조 변수이므로, 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. | 함수를 호출하면, 인자와 this가 암묵적으로 함수 내부로 전달된다. | 함수 내부에서 인자를 지역 변수처럼 사용할 수 있는 것처럼, this도 지역 변수처럼 사용할 수 있다. | this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다. | 크게 전역에서의 사용 / 함수 안에서의 사용으로 나뉠 수 있다. | . | 브라우저라는 자바스크립트 런타임의 경우, this는 항상 window라는 전역 객체를 참조 | 전역 객체 : 전역 범위에 항상 존재하는 객체를 의미함 (Node.js에서 전역 객체는 global) | 브라우저라는 자바스크립트 런타임에서 모든 변수, 함수는 window라는 객체의 프로퍼티와 메소드이다. | this를 함수 내부에서 사용한 경우 . | 현재 함수를 실행하고 있는 그 객체 참조 | 함수 내부의 this 값은 함수를 호출하는 방법에 따라 바뀜 | 엄격 모드 여부에 따라 참조 값이 달라짐 (엄격 모드에서 일반 함수 내부의 this는 undefined가 바인딩 됨) | . | . | super . | 자식 클래스 내에서 부모 클래스의 생성자 역할 | 자식 클래스에서 부모 클래스의 메소드 접근 역할 | super.을 이용하여 부모 클래스의 메서드에 접근할 수 있다. class Score{ constructor(math, english){ `this`.math = math; `this`.english = english; } sum() { return `this`.math + `this`.english; } avg() { const sum=`this`.sum(); console.log(\"평균 : \"+sum/2) } } class Student extends Score { constructor(math, english, science){ super(math, english); `this`.science = science; } avg(){ const sum = super.sum() + `this`.science; console.log(\"평균 : \"+sum/3) } } . | . | 화살표 함수 . | 함수 표현식에 대한 간결한 대안 (안되는게 있음) | 익명 함수로만 사용할 수 있다. | 약간의 의미적 차이와 의도적인 사용상의 제한을 가지고 있다. | 자체 바인딩이 this에 없다. | 인수 또는 super로 사용행 한다. | 메서드로 사용하면 안된다. | 생성자로 사용할 수 없다. | new로 호출하면 TypeError가 반환된다. | new.target 키워드에 대한 엑세스 권한도 없다. | 화살표 함수는 함수 내부에서 yield를 사용할 수 없으며 제너레이터 함수로 생성할 수 없습니다. | this가 동적으로 바인딩 되지 않고, 선언할 때 바인딩할 객체가 정적으로 결정된다. (화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. Lexical this) | . | anonymous function (익명함수) . | 사용자가 따로 함수를 만들 때 이름을 지정하지 않고 변수 혹은 그냥 호출만으로 선언할 수 있는 함수 | 런타임에 동적으로 선언된다. let func = function (){ let v2=1; } // func라는 변수에 할당되긴 했지만, func는 단순히 변수 이름일 뿐 함수의 이름이 아니다. | . | named function (기명함수) . | 이름이 붙여진 함수 | 런타임 이전에 선언된다. 클래스 / 객체 / 인스턴스 . | . | 클래스 . | 설계도 | 어떠한 변수와 메소드를 가지는지 적어놓은 것 | . | 객체 . | 클래스로 구현할 어떤 것 | 구현하고 싶은 것 | . | 인스턴스 . | 객체의 실체화 | 객체의 생성자를 통해 인스턴스라는 것으로 실체화 시켜야 함 | 객체의 복사된 내용 (e.g. new 연산자) 모든 객체는 Object의 인스턴스이다. 즉, Object는 객체 클래스 중 최상위 클래스이다. Object는 기본적인 객체를 생성하기 위한 내장 생성자 함수이다. (모든 객체는 Object의 프로퍼티와 메서드를 상속함) obj instance of Class // obj가 Class에 속하는지 아닌지 판단하는 연산자이다. 이 연산자는 오른쪽 피연산자로 생성자 함수를 사용한다. 하지만, 사용자가 직접 정의한 생성자 함수와 내장 생성자 함수 둘다 오른쪽 피연산자가 될 수 있으므로, 구분하기 어려울 수 있다. Promise . 모듈 . 파일이 여러개 분리되어 있을 때 분리된 파일 각각을 모듈이라고 부름 자바스크립트 커뮤니티에서 특별한 라이브러리르 만들어 필요한 모듈을 언제든지 불러올 수 있게 해준다거나 코드를 모듈 단위로 구성해주는 방법을 만드는 등 다양한 시도름 함 . | . | AMD - 오래된 모듈 시스템 중 하나 / require.js라는 라이브러리를 통해 처음 개발됨 | CommonJS - Node.js 서버를 위해 만들어진 모듈 시스템 | UMD - AMD와 CommonJS 간의 다양한 모듈 시스템을 함께 사용하기 위해 만들어짐 스크립트 하나는 모듈 하나 export, import를 적용하면 다른 모듈을 불러와 불러온 모듈에 있는 함수를 호출하는 것과 같은 기능 공유를 할 수 있음 | export 지시자 : 변수나 함수 앞에 붙이면 외부 모듈에서 해당 변수나 함수에 접근할 수 있다. | import 지시자 : 외부 모듈의 기능을 가져올 수 있다. 항상 엄격 모드로 실행된다. 모듈 레벨 스코프 [[Javascript#Scope]] 비동기 처리 . Web API : 웹 브라우저에서 제공하는 API로 AJAX나 Timeout등의 비동기 작업을 실행 Task Queue : Callback Queue라고도 하며 Web API에서 넘겨받은 Callback함수를 저장(선입선출 방식) Event Loop : Call Stack이 비어있다면 Task Queue의 작업을 Call Stack으로 옮김 . | . JS는 싱글 스레드 언어여서, 동기적 요청을 통해 코드를 하나하나 처리한다. 이러한 특성 때문에, 콜스택에 실행 컨텍스트가 남아있는 동안 브라우저는 아무것도 할 수 없다. 이러한 문제를 비동기 처리로 해결 가능함 . | e.g. | A 함수가 있다. | A 함수는 생성 단계를 거쳐 실행 단계를 지나면, 다른 실행컨텍스트와 같이 콜스택에서 제거된다. | 이 때, A 함수 내부에서 다른 API에게 콜백 함수와 함께 타이머를 보낸다. | 타이머가 다 되면, 해당 API는 A함수의 콜백함수를 테스크 큐에 밀어넣는다. | 테스크큐는 콜스택이 비어있는 것을 보고 테스크 큐에 콜백 함수를 콜스택에 전달한다. | 콜스택은 함수를 실행한다. 변수 . | . | var . | var 선언은 전역 범위 혹은 함수 범위로 지정됨 | 호이스팅 [[Javascript#실행 컨텍스트 (Execution context)]] | . | let . | 해당 블록 내에서만 사용이 가능하다. (중괄호) | let은 업데이트 될 수 있다. | 다만, 다시 선언할 수는 없다. let test=1; let test=2; // Uncaught SyntaxError: Identifier 'test' has already been declared . | . | const . | 선언된 블록 범위 내에서만 접근 가능함 | 업데이트, 재선언 둘 다 불가능하다. | 개체의 경우는 조금 다른데, 개체 자체는 업데이트 할 수 없지만, 개체의 속성은 업데이트 할 수 있다. | 콜 스택 주소값의 변경을 허락하지 않는다는 뜻 Reference . https://velog.io/@y_jem/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8 https://curryyou.tistory.com/276 기타 블로그들.. | . | . ",
    "url": "/docs/background/javascript/#background",
    
    "relUrl": "/docs/background/javascript/#background"
  },"51": {
    "doc": "Javascript",
    "title": "Node vm",
    "content": "node:vm 모듈은 security mechanism이 아니라고 한다. -&gt; untrusted code를 쓰지 말아라.. 주로 다른 context에서 코드를 실행하기 위해 사용한다고 한다. simple usage . const vm = require('vm') const context = { x : 2 } const code = 'var y = 3; x += y;' vm.runInContext(code, context) console.log(context.x); // 5 console.log(context.y) // 3 . DoS attack . nodejs는 싱글 스레드이고 Event Loop에 의존하기 때문에 event loop를 heavy/endless한 작업들로 막으면, 서비스를 멈출 수 있다. const vm = require('vm'); const code = 'while(true){}'; vm.runInNewContext(code,{}); console.log('Never gets executed.') . infinite loop가 event loop를 main process안에서 막기 때문에, 멈춘다. 새로운 V8 Virtual Machine context에서 동작하는 것은 맞지만, 같은 process와 같은 event loop를 사용하기 떄문에 멈춘다.. Escaping the Sandbox . VM 모듈은 새롭게 실행될 코드의 context를 original code와 분리한다. 반? 격리된 context에서 실행된다고 봐도 될 것 같다. 하지만, 쉽게 탈출된다. this.constructor.constructor이런 느낌으로 간단하다 . &gt; const vm = require(\"vm\"); &gt; code = \"var x = this.y\" &gt; let context = {y:1} &gt; vm.runInNewContext(code,context) &gt; console.log(context.x) &gt; code = \"var x = this.constructor\" &gt; vm.runInNewContext(code,context); &gt; console.log(context.x); [Function: Object] &gt; code = \"var x = this.constructor.constructor\" &gt; vm.runInNewContext(code,context); &gt; console.log(context.x); [Function: Function] &gt; code = \"var x = this.constructor.constructor()\" &gt; vm.runInNewContext(code,context); &gt; console.log(context.x); [Function: anonymous] undefined . | this는 context를 참조한다. | this.constructor는 context의 constructor를 참조한다. (native code를 참조한다. 아마 ) | this.constructor.constructor 는 다른 native code function 이다. | this.constructor.constructor() anonymous wrapper를 가졌다. | . ",
    "url": "/docs/background/javascript/#node-vm",
    
    "relUrl": "/docs/background/javascript/#node-vm"
  },"52": {
    "doc": "Regex (with Python3)",
    "title": "Table of Contents",
    "content": ". | 메타 문자 . | ^ 문자 | $ 문자 | [ ] 문자 - 문자 클래스 | .(dot) 문자 - \\n를 제외한 모든 문자 | * 문자 | + 문자 | {} 문자와 ? 문자 | . | 파이썬 . | 함수 | 오브젝트 | 플래그 | . | . ",
    "url": "/docs/background/regex/#table-of-contents",
    
    "relUrl": "/docs/background/regex/#table-of-contents"
  },"53": {
    "doc": "Regex (with Python3)",
    "title": "메타 문자",
    "content": "$()*+.?[]\\^{}| 등이 존재하고, 특정 문자 혹은 문자 계열을 대신하여 표현하는 문자이다. 이를 이용하면 특정 규칙을 가진 여러 단어들을 하나의 패턴으로 함축할 수 있다. (메타 문자에 해당되는 문자 자체를 검색하고 싶은 경우, 백슬래쉬(\\)를 앞에 붙이면 된다.) . ^ 문자 . [^a] → a 가 아닌 것과 매치를 뜻한다. 그냥 사용할 경우, 문자열의 시작을 표현한다. $ 문자 . 문자열의 끝을 표현한다. [ ] 문자 - 문자 클래스 . [ ] 사이에 들어간 문자들과의 매치를 뜻한다. 하이폰 (-)를 사용하여 문자 사이의 범위를 패턴으로 하여 매치할 수 있다. 자주 사용하는 문자 클래스 . [0-9] 또는 [a-zA-Z] 등은 무척 자주 사용하는 정규 표현식이다. 이렇게 자주 사용하는 정규식은 별도의 표기법으로 표현할 수 있다. 다음을 기억해 두자. | \\d - 숫자와 매치된다. [0-9]와 동일한 표현식이다. | \\D - 숫자가 아닌 것과 매치된다. [^0-9]와 동일한 표현식이다. | \\s - 화이트스페이스(whitespace) 문자와 매치된다. [ \\t\\n\\r\\f\\v]와 동일한 표현식이다. 맨 앞의 빈칸은 공백 문자(space)를 의미한다. | \\S - 화이트스페이스 문자가 아닌 것과 매치된다. [^ \\t\\n\\r\\f\\v]와 동일한 표현식이다. | \\w - 문자+숫자(alphanumeric)와 매치된다. [a-zA-Z0-9_]와 동일한 표현식이다. | \\W - 문자+숫자(alphanumeric)가 아닌 문자와 매치된다. [^a-zA-Z0-9_]와 동일한 표현식이다. | . 대문자로 사용된 것은 소문자의 반대임을 추측할 수 있다.(dot) 문자 - \\n를 제외한 모든 문자 . a.b - \"a'+모든 문자+\"b\" a[.]b - \"a.b\" . 위와 같이 사용하고, 혼동하지 않도록 주의해야 한다. * 문자 . | 문자 앞에 나온 문자를 0번 이상 반복되면 매치된다. | . a*b - \"ab\", \"b\", \"aaaab\" 등과 매치 . + 문자 . 위의 * 문자와 거의 똑같지만, 앞에 나온 문자가 1번 이상 반복되면 매치된다. {} 문자와 ? 문자 . 앞에 나온 문자가 중괄호 안에 들어간 카운트 수 만큼 매치된다. a{2} # a 2개 a{2,5} # a 2개 ~ 5개 . ? 는 {0,1}과 같다. ",
    "url": "/docs/background/regex/#%EB%A9%94%ED%83%80-%EB%AC%B8%EC%9E%90",
    
    "relUrl": "/docs/background/regex/#메타-문자"
  },"54": {
    "doc": "Regex (with Python3)",
    "title": "파이썬",
    "content": "함수 . | match . 문자열의 시작부터 패턴과 일치하는지 확인한다. # re.match(pattern,string,flag) re.match('a','ab') # O re.match('b','ab') # X . | search . 문자열에 패턴과 일치하는 결과가 있는지 확인한다. # re.search(pattern,string,flag) re.search('a','ab') # O re.search('b','ab') # O . | findall . 문자열에 패턴과 일치하는 결과가 있는지 확인하고, 여러 개일 경우, 모든 결과를 리스트로 반환한다. # re.findall(pattern,string,flag) re.findall('a','a') # ['a'] re.findall('a','aaaaaaa') # ['a', 'a', 'a', 'a', 'a', 'a', 'a'] re.findall('aaa','aaaaaaaaa') # ['aaa', 'aaa', 'aaa'] . | finditer . findall과 비슷하지만, 리스트가 아닌 iterator 형식으로 반환한다. # re.finditer(pattern,string,flag) re.finditer('a','a') # iterator 객체 re.finditer('a','aaaaaa') # iterator 객체 . | fullmatch . 문자열과 패턴이 완벽하게 일치하는지 확인한다. # re.fullmatch(pattern,string,flag) re.fullmatch('a','a') # O re.fullmatch('a','aa') # X re.fullmatch('a','ab') # X . | split . 문자열에서 패턴이 맞으면 이를 기점으로 쪼갠다. (최대 split 수를 설정하면 지정한 수 만큼 쪼개고, 나머지 뒤 문자열을 리스트의 마지막에 추가한다) . # re.split(pattern,string,max split,flag) re.split('a','a') # ['', ''] re.split('a','bab') # ['b', 'b'] . | sub . 문자열에 맞는 패턴을 교체할 문자열로 교체한다. (최대 sub 수를 설정하면, 지정한 수 만큼 교체하고, 나머지 뒤 문자열은 그대로 둔다) . # re.sub(pattern,string,max sub,flag) re.sub('a','z','a') # z re.sub('a','zz','ab') # zzb . | subn . sub와 동작은 비슷하지만, (문자열, 매칭 횟수) 형태로 반환한다. # re.subn(pattern,string,max sub,flag) re.subn('a','z','a') # ('z',1) re.subn('a','zz','aaab') # ('zzzzzzb', 3) . | compile . 패턴과 플래그가 동일한 정규식을 여러번 사용할 때 쓴다. # re.compile(pattern,flag) a = re.compile('a') a.search('abab') # O . | purge . compile로 만든 객체는 보통 100개까지 캐시에 저장하고, 그 수를 넘어가면 초기화 된다. purge 함수는 100개가 넘어가지 않아도 캐시를 초기화 할 수 있다. | escape . 패턴을 입력 받으면, 특수문자들에 이스케이프(백슬래쉬) 처리를 한 후, 반환한다. # re.escape(pattern) re.escape(\"a\") # 'a' re.escape(\"a{2,3}b\") # 'a\\\\{2,3\\\\}b' . | . 오브젝트 . 함수의 반환이 match object로 반환되는 경우, group(), start(), end() 등의 함수를 사용할 수 있다. | groups . 일치하는 모든 서브 그룹을 포함하는 튜플을 반환한다. 기본 값은 None이다. | group . group(0), group(1) 과 깉이 사용할 수 있고, groups 튜플의 index 접근과 비슷하다. | groupdict . (?P&lt;group_name&gt;PATTERN) 와 같이 정규표현식을 그룹화하고, 네이밍한 결과를 딕셔너리 형태로 반환 받을 수 있다. a=re.match(\"(?P&lt;Test&gt;a*)\",\"aaa\") a.groupdict() # {'Test': 'aaa'} . | . 플래그 . | DOTALL(S) - .(dot)이 줄바꿈 문자를 포함해 모든 문자와 매치될 수 있게 한다. | IGNORECASE(I) - 대소문자에 관계없이 매치될 수 있게 한다. | MULTILINE(M) - 여러 줄과 매치될 수 있게 한다. ^, $ 메타 문자 사용과 관계 있는 옵션이다. | VERBOSE(X) - verbose 모드를 사용할 수 있게 한다. 정규식을 보기 편하게 만들 수 있고 주석 등을 사용할 수 있게 된다. | . ",
    "url": "/docs/background/regex/#%ED%8C%8C%EC%9D%B4%EC%8D%AC",
    
    "relUrl": "/docs/background/regex/#파이썬"
  },"55": {
    "doc": "Regex (with Python3)",
    "title": "Regex (with Python3)",
    "content": " ",
    "url": "/docs/background/regex/",
    
    "relUrl": "/docs/background/regex/"
  }
}
